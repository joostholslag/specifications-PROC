= Material to remove?

== Iteration

Iteration in EL is performed over container and interval objects, i.e. variables or manifest constants. The general approach is to use built-in iterators of the container types, as follows.

----
    do_all (proc(v: T))
            -- execute proc(v) for every v in container

    do_if (proc(v: T); test(v: T): Boolean)
            -- execute proc(v) for every v in container for which test(v) is True

    do_while (proc(v: T); test(v: T): Boolean)
            -- execute proc(v) for every v in container until test (v) returns False

    do_until (proc(v: T); test(v: T): Boolean)
            -- execute proc(v) for every v in container until test (v) returns True
----

Iteration over a range of integers can be performed using an `Interval<Integer>` literal, as follows:

----
    (|1..5|).do_all (
        (v: Integer)
            do
                -- statements
            end
    )
----

[.tbd]
TBD: more on how this works (it's defined on `Discrete_interval<T>`)

== Representation Scheme

The general approach to representation for Decision Logic Modules (DLMs) and Subject Proxy Objects (SPOs) is to support two forms. The first is using Decision Language, designed for use by domain experts DL is a small formalism that builds upon the {openehr_expression_language}[openEHR Expression Language^], whose meta-model is defined in the {openehr_bmm}[openEHR Basic Meta-Model (BMM)^]. DL adds constructs for representing conditions, decisions, and modules. A small extra meta-model and syntax covers Proxy definition, and the importation and binding semantics in the binding objects. DL abstracts away detail typically required by a programming language, and also provides some higher level abstractions, such as complex type operators, temporal logic and so on. DL texts are assumed to be written by hand, with the aid of a syntax mode for typical editors, or a light-weight UI tool.

The second form is an expression in a standard programming language which is either generated from the DL form by a cross-compilation process, or directly generated by a more sophisticated UI tool. This direct expression will be significantly more complex, because it encompasses not just the decision logic and proxy definitions, but the ability to compute recommendations (i.e. decision proposals), reasoning chains and other advanced functionality requiring transparent access to the logic structures of a DLM.

The two types of artefacts are shown below.

[.text-center]
.Representation scheme
image::{diagrams_uri}/artefact_scheme.svg[id=artefact_scheme, align="center"]

== DLM Service Model

The following shows an outline idea of a DLM service interface. This could be made to cater for talking to an OMG DMN service. It could also incorporate the CDS-hooks idea, which is just a recommendation structure.

[.text-center]
.Service Model
image::{diagrams_uri}/conceptual_service_model.svg[id=conceptual_service_model, align="center"]

== SPO Overview

From a data perspective, the set of features defined in an SPO will relate to a particular use. For example, the properties for a leukaemia patient are likely to include `white_cell_count`, `platelets` and so on, while a SPO for ante-natal use will contain obstetric properties. A core set of SPO features for any patient would include clinical basics such as date of birth, sex, and typical vital signs. In general, the collection of features in an SPO will be a somewhat arbitrary 'slice' of all possible variables and events characterising a real-world entity. 

The following illustrates two SPOs, one a specialisation of the other.

[.text-center]
.Abstract proxy
image::{diagrams_uri}/conceptual_proxy.svg[id=conceptual_proxy, align="center"]

=== Variable Naming

[.tbd]
TBD: basic question of variable like 'Apgar 5min heartrate' - represent in a structure, and reference like `apgar_result.5min.heart_rate`, or just use flat pre-coord approach: `apgar_result_5min_heart_rate`? Structuring probably makes authoring easier.