== Events

=== Overview

Work plans interact with events in the external world, as well being driven by time. In this model, moments in time are modelled in terms of Events that represent the _reaching_ of certain points in time or an entry in a calendar, as time passes. Consequently, specifying a time for a Task to be performed and waiting for certain Events before it can be performed are both specified in terms of 'events'. The relevant part of the model, shown below, consists of various types of Events, and additionally, various types of _wait states_ that may be used to intercept them.

[.text-center]
.proc.task_planning model - Events
image::{uml_diagrams_uri}/PROC-task_planning.definition-event.svg[id=proc_task_planning_definition_event, align="center"]

Two general classes of Events are distinguished:

* _deterministic_: Events guaranteed to occur at a knowable point in time (shown on the lower left in light pink);
* _non-deterministic_: Events that might never occur (shown on the lower right in magenta).

For non-deterministic events, a timeout handler is generally needed.

=== Event Types

The various Event types are shown below, with their TP-VML representations.

[cols="1,<2,4", options="header"]
|===
|Type   |TP-VML |Description

3+|*Deterministic Events*

|`TIMER_EVENT`
a|image::{diagrams_uri}/event_timer.svg[id=event_timer]
|Event generated by the expiry of a Timer that was launched at some earlier time; if attached to a Task wait state, the timer is launched at the moment execution reaches the Task.

|`TIMELINE_MOMENT`
a|image::{diagrams_uri}/event_timeline_moment.svg[id=event_timeline_moment]
|Event generated by system clock reaching a fixed time-point on the Work Plan timeline, specified by an offset from the Work Plan origin (overridable) plus an optional fixed time in the day. The latter enables fixed points in time such as a particular hour of day or customary time such as 'afternoon' to be specified. A combination of the two such as `P2D`, `13:30:00` can thus be used to state a time like '13:30 on day 2 of the plan'.

|`CALENDAR_EVENT`
a|image::{diagrams_uri}/event_calendar_event.svg[id=event_calendar_event]
|Event generated by system clock reaching an event in the global Plan calendar, which is specified in absolute time, independent of the Work Plan timeline. The value of the `_time_` attribute is obtained from the calendar.

3+|*Non-deterministic Events*

|`TASK_TRANSITION`
a|image::{diagrams_uri}/event_task_transition.svg[id=event_task_transition]
|Event generated by the lifecycle transition of another Task, such as transition to `cancelled` or `done`. +
 NOTE: not needed for transition of the preceding Task to a terminal state, since in this case, execution automatically proceeds to the current Task.

|`STATE_TRIGGER`
a|image::{diagrams_uri}/event_state_trigger.svg[id=event_state_trigger]
|An event generated by a change in a tracked variable, or a Boolean expression based on tracked variables, e.g. a value reaching a threshold.

|`MANUAL_NOTIFICATION`
a|image::{diagrams_uri}/event_manual_notification.svg[id=event_manual_notification]
|An event that is manually notified to the Plan execution engine by a user.

|`SYSTEM_NOTIFICATION`
a|image::{diagrams_uri}/event_system_notification.svg[id=event_system_notification]
|An event that is notified to the Plan execution engine by a system.

|`CALLBACK_NOTIFICATION`
a|image::{diagrams_uri}/event_callback.svg[id=event_callback]
|A callback notification connected to a dispatch for a Dispatchable Task (Hand-off, External Request, System Request).

|===

Instances of all of these types on their own only identify the type and source of an event - a wait state is required to catch an event. There are three types of wait state used in a TP definition: Task Wait, Timer Wait and Callback Wait. These are described below.

The following Event types require further explanation.

==== TIMELINE_MOMENT

The `TIMELINE_MOMENT` event type represents an event generated by the system when a point in time on the execution clock is reached. The time point is specified by two attributes, `_timeline_offset_` and `_fixed_time_`, with the time origin (default: Work Plan activation) being optionally specified by `_timeline_origin_`. At least one of the first two attributes must be set.

If `_fixed_time_` is set using an instance of `CLOCK_TIME`, it refers to the first moment at which the time occurs during the day, _after any offset has elapsed_. The following diagram shows how this works for two instances of `TIMELINE_MOMENT`, both having a `_fixed_time_` of `07:30` and a `_timeline_offset_` of `P1d` (one day), when the timeline origin is different (i.e. the Work Plan was started at different times).

[.text-center]
.`TIMELINE_MOMENT` semantics
image::{diagrams_uri}/timeline_moment_semantics.svg[id=timeline_moment_semantics, align="center"]

The `_fixed_time_` attribute may also be set using an instance of `CUSTOMARY_TIME`, to allow the time to be specified using coded terms like `morning`, `afternoon`, `evening` and so on. Such terms are assumed to define time ranges such as `07:00:00 - 11:30:00` etc, which are typically culturally specific, and/or specific to hospital or other institutional norms. Consequently, such terms have to be resolved to computable intervals by some means (e.g. a locale service API call), left up to the TP execution system. Where such an interval is used to define a time, the event is generated at the earliest time of the interval (e.g. `07:00:00` for 'morning')

If `_fixed_time_` is not set, it refers to the first moment in time directly after the offset, if any, has elapsed (i.e. a Void `_fixed_time_` is intepreted as "don't care"). If `_timeline_offset_` is not set, `_fixed_time_` is resolved to the first occurrence of the specified time directly from the time origin.

A `TIMELINE_MOMENT` with neithre of `_timeline_offset_` or `_fixed_time_` set is not considered meaningful, since it is equivalent to no `TIMELINE_MOMENT` event at all.

The timeline origin defaults to the moment of Work Plan activiation, but may be overridden via the `_timeline_origin_` attribute to be the moment of activation of the current Task Plan, or the entry into a repeating section (a Task Group or Task with `_repeat_spec_` set).

=== General Facilities

==== Event Wait State

The class `EVENT_WAIT<T>` defines a generic model of a general-purpose event wait state that may be specialised for particular purposes. Its attributes are as follows:

* `_success_action_` of type `EVENT_ACTION`, which defines possible actions to occur on receipt of an event;
* `_timeout_` of type `TIMER_WAIT`, whose `_success_action_` defines possible actions when no event is received.

The `EVENT_ACTION` type defines a number of things the system can do on a triggering event:

* make a system call, if the `_system_call_` attribute is set, e.g. to cause a notification to be sent or write to a system logger;
* displaying a message to the user, specified in the `_message_` attribute;
* optionally indicate a specific lifecycle state for the Plan Item (a Task or Task Group) receiving the event, specified by `_receiver_thread_next_state_`;
* optionally indicate where execution should resume in the plan, for example at an earlier Task, via the `_resume_action_` attribute, whose value is an instance of `RESUME_ACTION`, defining the `_resume_type_` and `_resume_location_` attributes.
    
==== Timers

A generic timer can be specified using `TIMER_WAIT`, a specialisation of `EVENT_WAIT<TIMER_EVENT>` based on the Event type `TIMER_EVENT`. This provides a way to specify a Timer (the `TIMER_EVENT`) and listen for it (the `TIMER_WAIT`).  A `TIMER_WAIT` creates a separate Event wait state that listens for a Timer event launched some duration after Task activation, and may result in specific actions, specified via the inherited `EVENT_WAIT._success_action_` attribute.

The timer represented by a `TIMER_EVENT` is started when the wait state to which it is attached is reached in the execution.

==== Reminder

A reminder can be specified using `REMINDER`, a specialisation of `EVENT_WAIT<PLAN_EVENT>`. Conceptually, a reminder is a wait state that is activated if a secondary event (represented by the `_event_` attribute inherited from `EVENT_WAIT<T>`) occurs in the absence of waited-on primary event(s), i.e. expected lifecycle transitions of the owning Task. Usually the secondary event is a `TIMER_EVENT`, but it could be anything else. If any of the primary events occurs, the reminder is cancelled.

=== Task Wait State

The principal way to wait for events is via the `TASK_WAIT` attachable to any `PLAN_ITEM` via the `_wait_spec_` attribute. The `TASK_WAIT` class represents a wait state that defines when a Task should enter the `available` state from the `planned` state in terms of Events of the types described above. Its `_events_` attribute enables multiple Events to be used as triggers, with an assumed logical OR relation among them. This enables the specification of triggers such as 'at 8pm on day 1, OR when oxygen saturation drops below 90% (whichever comes first)'. The optional `_event_relation_` attribute allows the Task to be specified as commencing `before`, `with` or `after` the trigger event (such as a meal). 

The following figure illustrates typical uses of `TASK_WAIT`.

[.text-center]
.Task wait state 
image::{diagrams_uri}/task_wait_state.svg[id=task_wait_state, align="center"]

==== Time-outs

A timeout can be set on a Task Wait state by setting `TASK_WAIT._timeout_` with a `TIMER_WAIT` instance, which is activated when the Task Wait state is reached in the execution. This is useful in cases where Event receipt is not certain. The `TIMER_WAIT` generates a timer event if no other event is received; conversely, receipt of any other event cancels the timeout timer. The `TIMER_EVENT` attached to `TIMER_WAIT._event_` indicates the duration of the timer. The `_success_action_` of the `TIMER_WAIT` indicates actions to execute if the timer fires. The following Plan fragment illustrates.

[.text-center]
.Timing patterns
image::{diagrams_uri}/uc_task_timing_1.svg[id=timing_patterns_1, align="center"]

==== Reminder

When an event specified in `TASK_WAIT._events_` fires, it puts the Task into the `available` lifecycle state. In typical real world situations, the performer may not realise, or may be busy on something else. To enable the performer to be reminded, the `PLAN_ITEM._reminders_` attribute may be used to specify one or more `REMINDER` wait states. Each of these will have a `TIMER_EVENT` (or other event) as its firing `_event_`.

[.tbd]
TBD: what about transition to `underway`?

If a Reminder is activated, it will generate a notification, specified via the inherited `_success_action_` attribute. If still no activity occurs for some time, additional reminders may fire (due to Timer events with longer times), and generate new notifications. As soon as the performer progresses the Task to a new state, any reminder for which such a transition is cancelling, will be cancelled. An example is illustrated below.

[.text-center]
.Task wait state with reminder
image::{diagrams_uri}/task_wait_state_reminder.svg[id=task_wait_state_reminder, align="center"]

==== Lifecycle Transition Override

In some cases, it may be necessary to progress a Task to a state other than `available`. This may be achieved by specifying `TASK_WAIT._next_state_`.

=== Callbacks

A callback is the mechanism to state what happens when control returns to a Dispatchable Task (such as a Hand-off or External Request) from its target. It is defined in the model by `CALLBACK_WAIT`, a specialisation of `EVENT_WAIT<CALLBACK_NOTIFICATION>`, which represents a wait state to receive notifications of Dispatch completion, as well as timeout if no response is received. The callback event is formally represented by the `CALLBACK_NOTIFICATION` class. These classes are shown in the following view of the UML model.

[.text-center]
.Callback Wait
image::{uml_diagrams_uri}/PROC-task_planning.definition-callback_wait.svg[id=proc_definition_callback_wait, align="center"]

In order to define the processing on receipt of a callback event, `CALLBACK_WAIT` adds two attributes to `EVENT_WAIT<T>`:

* `_fail_action_`: enables a different `EVENT_ACTION` to be specified on receipt of a callback with a 'fail' status;
* `_custom_actions_`: enables a custom set of `EVENT_ACTIONs` to be specified, in the form of a Hash table, with a specific Event Action for each key; the keys are assumed to represent specific return statuses of the remote Task.

A Callback Wait thus has three standard Event responders: `_success_action_`, `_fail_action_` and `_timeout_`, and additionally any number of custom responders definable via `_custom_actions_`, described later.

A callback at execution time is achieved either internally in the TP system, or externally in the real world (e.g. by the subject returning to a clinic reception), which requires it to be manually signalled to the TP engine. The notification route is indicated by the attribute `CALLBACK_NOTIFICATION._manually_notified_`. In both cases, the `CALLBACK_NOTIFICATION` event carries the details of the event to be matched. In the manual notification, matching of `_subject_id_` etc will be carried out manually, e.g. by staff identifying the patient.

Task lifecycle state processing for a Dispatchable Task occurs both at the point of dispatch and return and/or timeout. The general model is as follows:

* the Task starts in the `planned` state, as for any Task in a Plan;
* when the execution point reaches the Task, and any Task Wait state has been exited, the Task becomes `available` (refer above to <<_task_availability>>);
* the Task dispatch operation is performed either automatically, or in the case of an External Request, manually;
* if `DISPATCHABLE_TASK._wait_` is `False`:
** the Task transitions to the `completed` state.
* if `DISPATCHABLE_TASK._wait_` is `True`:
** the Task enters the `underway` state until a callback (or timeout) occurs, at which point the next state will depend on the details of the callback (see below);

==== Callback Processing for Blocking Tasks

For a `DISPATCHABLE_TASK` that blocks and waits in the `underway` state, there are three callback processing models:

* `standard`: generic `success | fail | timeout` model;
* `order tracking`: used if `DISPATCHABLE_TASK._order_tags_` is set;
* `custom`: used if `DISPATCHABLE_TASK._callback.custom_actions_` is set.

Each model corresponds to a different set of possible callback statuses returned by the TP engine with the callback notification to represent the state of the remote Task execution. In the `standard` model it is a generic `success | fail | timeout` approach. Under the `order tracking` model (<<_order_tracking>>, above), the return statuses are states from the {openehr_rm_ehr}#_the_standard_instruction_state_machine_ism[openEHR Instruction State Machine]. Under the `custom` model, they are specific to the context.

Under each model, the next lifecycle state of the Dispatchable Task is determined by the callback status in a specific way. For each possible status under each model, a specific callback handler may be set, defined in terms of the `CALLBACK` properties `_success_action_`, `_fail_action_`, `_timeout.success_action_`. Any of these (see class `EVENT_ACTION`) if set may override the default next state, and also may generate a system call and/or a message for the performer.

[.tbd]
TBD: It would be reasonable to design an implementation with a default message of the form `"Task $task_name[id=$task_id] completed with $state"`, and a global flag `_default_messages_on_` to obviate the need to always set basic messages in `EVENT_ACTION`.

In special cases, it may also cause execution to resume in another place (see <<_resume_semantics>>).

A common approach to timeout processing applies to all models. If no callback occurs, and `CALLBACK._timeout.success_action_` is set, its timer will be used to generate the timeout, and also to determine the next state, message etc. If it is not set, the Work Plan global timeout will be triggered to unblock the Task and transition it to the `abandoned` state.

[.tbd]
TBD: need to define Plan level timeout.

The following table describes the details of callback processing under the various models.

[cols="2,2,3,3,3", stripes=none, options="header"]
|===
|Callback +
 model       |Callback +
              statuses |Dispatchable Task +
                        settings            |Response processing    |Notes

.2+a|*Standard*
.2+|_success_ +
 \| _fail_ +
 \| _timeout_
|no callback handlers
a|
* _success_ -> `completed` +
* _fail_ -> `abandoned` +
* _timeout_ -> `abandoned`
|

|callback handlers (`_success_action_`, `_fail_action_`, `_timeout.success_action_`)
a|As specified in `EVENT_ACTION.` +
 `_receiver_thread_next_state_`, +
 or else as above.
|Use to e.g. convert _fail_ to `cancelled`.

.2+a|*Order +
 tracking*
.2+|Action ISM state +
 \| _timeout_
|no callback handlers +
 (except optionally `_timeout.success_action_`)
a|
* `planned` -> `underway` +
* `cancelled` -> `cancelled` +
* `postponed` -> `suspended` +
* `scheduled` -> `underway` +
* `active` -> `underway` +
* `suspended` -> `suspended` +
* `aborted` -> `cancelled` +
* `completed` -> `completed` +
* _timeout_ -> `abandoned`
|May catch multiple callbacks via use of `underway` target state. +
 +
 Only target states reachable from `underway` can be used.

|callback handlers (`_custom_actions_`, `_timeout.success_action_`)
a|As specified in `_custom_actions[n]. +
 receiver_thread_next_state_`, +
 or else as above
|

a|*Custom*
|Custom statuses +
 \| _timeout_
|callback handlers (`_custom_actions_`, `_timeout.success_action_`)
a|
* `xxx` -> `underway` +
* `yyy` -> `cancelled` +
* `zzz` -> `suspended` +
* etc
* _timeout_ -> `abandoned`
|May catch multiple callbacks via use of `underway` target state. +
 +
 Only target states reachable from `underway` can be used.
 
|===

The following diagram shows the TP-VML definition for a dispatchable Task with a standard callback.

[.text-center]
.Standard callback example
image::{diagrams_uri}/uc_task_callback_1.svg[id=timing_callback_pattern_1, align="center"]

The following TP-VML definition illustrates a custom callback.

[.text-center]
.Custom callback example
image::{diagrams_uri}/uc_task_callback_2.svg[id=timing_callback_pattern_2, align="center"]

==== Callback Processing for Non-blocking Tasks

In the case of a context fork, the source Task has performed its work as soon as the dispatch has occurred, and its state is set to `completed`. The next Task(s) become `available` in the normal way, and processing continues. At some later point in time, a status notification of timeout may be received from the remote Task. This will be processed similarly to the above, with the exception that the next state processing, _if explicit next states are set_, is  _with respect to the enclosing Task Group_, which may be the top-level Group of the Task Plan. This allows the possibility of the callback processing to cause the local execution pathway to stop with abandonment, or cancellation. The default next-state processing is 'no change', i.e. the current execution path doesn't care what happens to the remote thread. However, if `EVENT_ACTION._receiver_thread_next_state_` is set for an execution status of the remote Task, the execution of the Task Group containing the source Task may be ended (`cancel`) or the whole Plan abandoned (`abandon`). Such a transition might even be set on `success`, which provides a way to model 'first one wins' logic.

The following illustrates a non-blocking callback in TP-VML.

[.text-center]
.Non-blocking callback example
image::{diagrams_uri}/dispatchable_no_wait_callback.svg[id=dispatchable_no_wait_callback, align="center"]

==== Callback with Custom Resume Behaviour

The attribute `EVENT_ACTION._resume_action_` of type `RESUME_ACTION`, and its attribute `_resume_location_` enable custom post-callback behaviour to be stated. The default is to process the `EVENT_ACTION` (e.g. post a message, make a system call etc), and then to complete the current Task and progress to the next in the normal way. A custom resume action alows a different resumption location to be specified, as defined by the enumeration `RESUME_TYPE`. This kind of resumption is described below in the section on <<_resume_semantics>>.

=== Class Definitions

include::{uml_export_dir}/classes/task_wait.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/event_wait.adoc[leveloffset=+1]
include::{uml_export_dir}/classes/timer_wait.adoc[leveloffset=+1]
include::{uml_export_dir}/classes/reminder.adoc[leveloffset=+1]
include::{uml_export_dir}/classes/callback_wait.adoc[leveloffset=+1]
include::{uml_export_dir}/classes/event_action.adoc[leveloffset=+1]
include::{uml_export_dir}/classes/resume_action.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/plan_event.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/timer_event.adoc[leveloffset=+1]
include::{uml_export_dir}/classes/calendar_event.adoc[leveloffset=+1]
include::{uml_export_dir}/classes/timeline_moment.adoc[leveloffset=+1]

include::{uml_export_dir}/classes/task_transition.adoc[leveloffset=+1]
include::{uml_export_dir}/classes/manual_notification.adoc[leveloffset=+1]
include::{uml_export_dir}/classes/system_notification.adoc[leveloffset=+1]
include::{uml_export_dir}/classes/callback_notification.adoc[leveloffset=+1]
include::{uml_export_dir}/classes/state_trigger.adoc[leveloffset=+1]
